import sim
import utils
import ui
import shapes
import interactive
import plots

import glm
import time
import numpy as np

def deg2rad(deg):
    return deg / 180 * np.pi

def rad2deg(rad):
    return rad * 180 / np.pi

INTENDED_FPS = 60
Color = sim.Color

sim.init(width=1600, height=800, scale=1)
s = sim.state.scale
frame_update = utils.FpsCounter(update_interval_sec=1/INTENDED_FPS)
fps = utils.FpsCounter()

mov_reference = interactive.Movable(shapes.Circle, [0.5, 0.5],
        0.05, filled=True)
sim.interactive_add(mov_reference)

def ref_to_angle():
    ret = np.arctan2(mov_reference.shape.C.y, mov_reference.shape.C.x)
    if ret < 0:
        ret = np.pi * 2 + ret
    return ret

d_t = 1/INTENDED_FPS
K_t = .0182
K_e = .0182
R = 0.83 
L = 0.00063
g = 9.81
m = 0.1
r = 0.1
sim_state = sim.dotdict({
    'err_state': 'None',
    'angle': deg2rad(-60),
    'angl_speed': 0,
    'angl_acc': 0,
    'ref_angle': ref_to_angle(),
    'vcc': 0,
    'time': None
})
sim_state.angl_acc = -g*np.sin(sim_state.angle)/r

angle_plot = plots.Plot(
    [1.0, 0.5], [2, 1],
    name="voltage",
    DA=(0, 0),
    DB=(5, 0),
    mode=plots.Defs.MODE_SLIDING,
)
angle_plot.mode_opts.append(plots.Defs.OPT_SLIDE_RESIZE_Y)
agraph = angle_plot.create_graph()

# Solve area(for the student to modify):
# ==============================================================================

pid_state = sim.dotdict({
    'prev_time': 0,
    'prev_angle': 0,
    'inited': False
})

# this function will get as input the current angle and time of the simulation
# and will output the desired voltage for the next period of time
def regulator(time, angle, ref_angle):
    if not pid_state.inited:
        pid_state.prev_time = time
        pid_state.prev_angle = angle
        pid_state.angle_integral = 0
        pid_state.inited = True
    dt = time - pid_state.prev_time
    da = (pid_state.prev_angle - angle) / d_t
    Kp = 10
    Ki = 10
    Kd = 4
    pid_state.angle_integral += (ref_angle - angle) * dt
    ret_v = (ref_angle - angle) * Kp + Ki * pid_state.angle_integral + Kd * da

    pid_state.prev_time = time
    pid_state.prev_angle = angle
    agraph.append_point(time, ret_v)
    return ret_v

# Simulation area(student can read it for reference):
# ==============================================================================

# http://www.gearseds.com/files/Lesson3_Mathematical%20Models%20of%20Motors.pdf
# https://www.youtube.com/watch?v=NH81md89QtA&ab_channel=MESe-Learning

# If we look at our motor from it's electrical perspective we can see it as an
# rezistor, a coil and an electrical source in series:
# 
#               i
#       Vcc o--->--|
#                  |
#                 SSS
#                 SSS L
#                 SSS
#                  |
#                 [ ]
#                 [ ] R
#                 [ ]
#                  |
#                  |
#                 ___
#               ------- E
#                  |
#                  |
#                 ___ 
#                  -  gnd
# 
# So we can write the following ecuation using Kirchhoff's voltage law:
#   Vcc = L*di/dt + R*i + E                                                 (1)
# 
# Where:
# L - the inductance
# R - the resistance
# i - the current
# E - the electromotive force generated by the motor
# Vcc - the voltage applied to the motor's terminals
# 
# We know about our motor that
#   E = k_e*w(t)                                                            (2)
# 
# where:
# w(t)- the angular speed of the motor(notice we ommit (t) subscript most of
#       the time)
# k_e - the voltage constant of the motor
# 
# We also know about our motor that
#   Tm = k_t*i                                                              (3)
# 
# where:
# Tm - the torque generated by our motor
# k_t - the torque constant of the motor
# 
# Our motor will have a rod of neglijible mass attached to it and a point-like
# weight attached to the and of the rod, so the moment of inertia of our
# attachment will be
#   J = m*r^2                                                               (4)
# 
# where:
# J - the moment of inertia
# m - the mass of our point-like weight
# r - the distance from the weight to the axis of the motor
# 
# Our motor would look like this:
#                     
#                      O m
#                     /|
#                    / v G
#                   /
#           |------/-|
#      vcc -|     /  |
#           |   [ ]  |
#      gnd -|        |
#           |--------|
# 
# And on m the gravitational force will act, resulting the gravitational torque
#   Tg = -r*G*cos(angle)                                                    (6')
# or
#   Tg = -r*m*g*cos(angle)                                                  (6)
# 
# where:
# Tg - the gravitational torque
# G - the gravitational force acting on m
# angle - the current angle made by the rod with the horizontal axis
# g - the gravitational acceleration in earth's proximity
# 
# Now from the mechanical and electrical representations of the motor we can
# derive some equations. First we have the total torque applied:
#   T = Tg + Tm                                                             (7)
# 
# From 7, 6, 3 and substituting a(t) = angle(t) =>
#   T = -r*m*g*cos(a) + K_t*i                                               (8)
# 
# But we have the relation:
#   T(t) = J*dw/dt                                                          (9)
# 
# Hence, from 9, 8, 7:
#   m*r^2*dw/dt = -r*m*g*cos(a) + K_t*i
# or:
#   i = (m*r^2*dw/dt + r*m*g*cos(a))/K_t                                    (10)
# 
# By substituting 10 in 1 and using 2 we can write:
# 
#                 d^2w                            dw
#           m*r^2*---- - r*m*g*w*sin(a)     m*r^2*-- + r*m*g*cos(a)
#                 dt^2                            dt
#   Vcc = L*--------------------------- + R*----------------------- + K_e*w (11)
#                       K_t                           K_t
# 
# Observing that w = da/dt we can re-write 11:
# 
#           d^3a         da
#     m*r^2*---- - r*m*g*--*sin(a)
#           dt^3         dt
#   L*---------------------------- +
#                 K_t
# 
#                           d^2a
#                     m*r^2*---- + r*m*g*cos(a)
#                           dt^2                      da
#                 + R*------------------------- + K_e*-- - Vcc = 0          (12)
#                            K_t                      dt
# 
#   And now 12 is the differential equation that we must solve. Solving for a(t)
# will give us the angle at any time we desire for the given voltage at the
# terminals. If we so desire we can even modify the voltage, with Vcc=Vcc(t),
# where Vcc(t) will be our desired function.
#   There is only one small problem, I don't know how to solve it, that's a 
# third-order nonlinear ordinary differential equation. Don't let that ordinary
# part fool you, that's not a simple problem. But we have a way around it: we
# will aproximate the solution.
#
# First, because we are going to aproximate the solution, we need to look at the
# parameters of our system.
# 
# TODO: fix /rad
# K_t = 18.2 * 10^-3 N-m/A          [kg*m^2/(s^2*A)]
# K_e = 18.2 * 10^-3 V/(rad*s)      [kg*m^2/(A*s^3*rad)]
# R = 0.83 Ohm                      [kg*m^2/(A^2*s^3)]
# L = 0.63 * 10^-3 H                [kg*m^2/(A^2*s^2)]
# m = 10^-1 kg
# r = 10^-1 m
# g = 9.81 m/s^2
# 
# Where:
# N-m: Newton meters [kg*m^2/s^2]
# V: Volts [kg*m^2/(A*s^3)]
# rad: radians
# Ohm: Ohm [kg*m^2/(A^2*s^3)]
# H: Henry [kg*m^2/(A^2*s^2)]
# s: seconds (SI unit)
# A: Amperes (SI unit)
# kg: Kilogram (SI unit)
# m: metre (SI unit)
#
# And because we will simulate our process we must talk about the time that
# passes between two simulation steps:
# 
# d_t = 1/60 s ~= 0.0166 s (from delta time, do not confuse it with dt)
# 
# So let's calculate some of the coeficients that participate in our
# differential equation(from 12):
# 
# L*m*r^2   0.63 * 10^-3 * 10^-1 * 10^-2
# ------- = ---------------------------- = 0.00003461538 [kg*m^2/A] = a1    (13)
#   K_t             18.2 * 10^-3
# 
# L*r*m*g   0.63 * 10^-3 * 10^-1 * 10^-1 * 9.81
# ------- = ----------------------------------- =
#   K_T                18.2 * 10^-3
# 
#         = 0.00339576923 [kg*m^2/(A*s^2)] = a2                             (14)
# 
# R*m*r^2   0.83*10^-1*10^-2
# ------- = ------------------ = 0.0456043956 [kg*m^2/(A*s)] = a3           (15)
#   K_t        18.2 * 10^-3
# 
# R*r*m*g   0.83*10^-1*10^-1*9.81
# ------- = --------------------- = 4.47379120879 [kg*m^2/(A*s^3)] = a4     (16)
#   K_t         18.2 * 10^-3
# 
# Substituting 13, 14, 15, 16 in 12 we get:
# 
#    d^3a      da             d^2a                   da
# a1*---- - a2*--*sin(a) + a3*---- + a4*cos(a) + K_e*-- - Vcc = 0           (17)
#    dt^3      dt             dt^2                   dt
# 
# or using the aproximative value of a1, a2, a3, a4 and K_e:
# 
#             d^3a             da                d^2a
# 0.034*10^-3*---- - 3.3*10^-3*--*sin(a) + 0.045*---- + 4.47*cos(a) +
#             dt^3             dt                dt^2
#
#                                           da
#                              + 18.2*10^-3*-- = Vcc
#                                           dt
#
# TODO: check if must keep paragraph
# At this point you can go take this equation and put it inside wolframalpha
# with some value of Vcc and see that it can plot a solution but it doesn't
# give you an analytical solution.
# 
# Good, now we have some better image of what this equation looks like now
# we can try to aproximate it's solution.
#
# TODO: integrator
# TODO: discuss aproximation error

# this function will take the voltage from the regulator as input and will
# update the state of the motor

def process(d_t, voltage, oangl, oangl_speed, oangl_acc):
    # a1 = 1
    a1 = L*m*r*r/K_t
    a2 = L*r*m*g/K_t
    a3 = R*m*r*r/K_t
    a4 = R*r*m*g/K_t
    yn = oangl_acc
    xn = oangl_speed
    an = oangl
    dy = -(a3*yn + xn*(K_e - a2*np.sin(an)) + a4*np.cos(an) - voltage)/a1
    an += xn * d_t
    xn += yn * d_t
    yn += dy * d_t

    return an, xn, yn

# this function will be called each update cicle in the main loop to update
# graphs and the representation of the motor
def update_fn():
    st = sim_state
    if not st.time:
        st.time = 0

    st.ref_angle = ref_to_angle()
    voltage = regulator(st.time, st.angle, st.ref_angle)
    step_cnt = 1000
    for i in range(step_cnt):
        st.angle, st.angl_speed, st.angl_acc = process(d_t/step_cnt, voltage,
                st.angle, st.angl_speed, st.angl_acc)
    st.time += d_t

# Draw area(the student can ignore the next part):
# ============================================================================== 

def draw_border():
    sim.draw_line([-s,-s], [-s,s], Color.BLACK)
    sim.draw_line([s, -s], [ s,s], Color.BLACK)

def draw_axis():
    # sim.draw_line([0, 0], [s, 0], Color.RED)
    # sim.draw_line([0, 0], [0, s], Color.BLUE)
    # sim.draw_line([0, 0], [0,-s], Color.GREEN)
    # sim.draw_line([0, 0], [-s,0], Color.BLACK)
    pass

def draw_motor():
    MOTOR_WIDTH = 0.15
    AXIS_RADIUS = 0.02
    ROD_LENGTH = 0.6
    ROD_END_RADIUS = 0.05
    PIN_SIZE = 0.04
    PIN_DISTANCE = 0.16

    # Draw motor body 
    ui.TextLine("Motor", pos=[0, MOTOR_WIDTH],
            align=(ui.XCENTER, ui.YBOTTOM)).draw()
    sim.draw_aabb([-MOTOR_WIDTH, -MOTOR_WIDTH], [MOTOR_WIDTH, MOTOR_WIDTH])
    
    # Draw motor pins
    sim.draw_line(
        [-MOTOR_WIDTH,             PIN_DISTANCE/2],
        [-MOTOR_WIDTH - PIN_SIZE,  PIN_DISTANCE/2]
    )
    # TODO: vcc este utilizat si pt curent variabil?
    ui.TextLine("vcc", pos=[-MOTOR_WIDTH - PIN_SIZE, PIN_DISTANCE/2],
            align=(ui.XRIGHT, ui.YCENTER)).draw()
    sim.draw_line(
        [-MOTOR_WIDTH,            -PIN_DISTANCE/2],
        [-MOTOR_WIDTH - PIN_SIZE, -PIN_DISTANCE/2]
    )
    ui.TextLine("gnd", pos=[-MOTOR_WIDTH - PIN_SIZE, -PIN_DISTANCE/2],
            align=(ui.XRIGHT, ui.YCENTER)).draw()
    
    # Draw motor axis
    sim.draw_circle([0, 0], AXIS_RADIUS)
    
    # Draw motor rod
    rod_end_dir = glm.vec2(
        np.cos(sim_state.angle),
        np.sin(sim_state.angle)
    )
    sim.draw_line(rod_end_dir * AXIS_RADIUS,
            rod_end_dir * (AXIS_RADIUS + ROD_LENGTH))
    sim.draw_circle(rod_end_dir * (AXIS_RADIUS + ROD_LENGTH + ROD_END_RADIUS),
            ROD_END_RADIUS, color=Color.RED, filled=True)

def draw_info_text():
    info_text = '\n'.join([
        'App info state:',
        '> fps: %.2f' % fps.get_fps(),
        '> err: %s' % str(sim_state.err_state),
        '> angle: %.1f' % rad2deg(sim_state.angle),
        '> vcc: %.3f' % sim_state.vcc,
        '> ref: %.3f' % rad2deg(sim_state.ref_angle)
    ])
    tb = ui.TextBlock(info_text, pos_px=(5, 5), limits_px=(195, 795))
    tb.draw()

def draw_fn():
    fps.update()
    if frame_update.update():
        if frame_update.fps < 1:
            for i in range(round(1/frame_update.fps)):
                update_fn()
            print("Frame took longer than %fs to be updated (%fs)" %
                    (d_t, 1/INTENDED_FPS*(1/frame_update.fps)))
        else:
            update_fn()

    angle_plot.draw()
    draw_border()
    draw_axis()
    draw_info_text()
    draw_motor()

sim.loop(draw_fn=draw_fn)
